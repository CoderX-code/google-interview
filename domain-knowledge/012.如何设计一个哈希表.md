# 如何设计一个哈希表

> 哈希表又称`散列表`

哈希表是编程中经常会用到的数据结构，很多编程语言都有其内部实现，比如Java的`HashMap`，JavaScript的`Map`（欢迎补充）

那么你有没有思考过如何设计一个`哈希表`呢，另外还需要回答以下三个问题：

1. 你需要用到哪些其他数据结构（提示：链表、树）
2. 你需要用到哪些算法进行数据`存储`和`查询`，这两者操作的时间复杂度是多少？为什么？
3. 哈希表是如何保证键唯一的

来源：北京某外企技术面试题

<details>

<summary>答案</summary>

### 概念解析

#### 散列函数(哈希算法)

将任意长度的二进制值串`映射`为固定长度的二进制值串

#### 散列冲突

通过散列函数计算出相同的散列值

#### 散列冲突解决

- 开放寻址法
  - 线性探测（依次查找空闲位置）
  - 二次探测（查找空闲位置的步长从1调整为下标的二次方）
  - 双重散列（使用多个散列函数查找新的空闲位置）
- 链表法
  - 每个桶对应一条链表，散列值相同的元素都放在该桶的链表上
  - 每个桶对应一个红黑树

#### 装载因子

已经记录的元素个数除以散列表容量长度，比如哈希表长度为16，当存储8个元素后，装载因子为8/16=0.5

### 答案解析

#### 问题1

最简单的哈希表设计可以利用数组，将元素的某些标识作为数组下标，对元素进行存储，这种方案适合数据量小的情况，当数据量大时会极大浪费内存空间。

更优的做法是设计一个散列函数，将元素特征通过散列函数计算得出一个相对唯一的散列值，然后使用计算出的散列值作为数组下标，确定元素的存储位置。

#### 问题2

存储值时使用到`哈希算法`计算哈希值，当装载因子较大时，可能涉及到`动态扩容`，需要增加新的存储空间，可以将新的哈希值存储至新申请的空间，并将老空间的一个元素移动至新空间，以此将每次存储的时间复杂度均摊到O(1)

查找时，需要根据查找内容计算出哈希值，并进行查找。最坏的情况下，在同一个链表上相同哈希值的元素非常多，查找的时间复杂度可能会退化到O(n)，所以需要在存储的过程中尽量动态调整不同元素的分布。

#### 问题3

哈希算法无法做到零冲突，因为哈希算法产生的哈希值是固定长度的，所以能表示的数据是有限的。比如MD5产生的串值长度为128位，能表示2^128(340282366920938463463374607431768211456)个数据。

当数据量超出这个范围后，无法保证键唯一，但数据量一般不会超出这个范围。


### 实现案例

#### Java的ThreadLocalMap

适用于数据量小、装载因子小的情况，使用开放寻址法解决散列冲突

#### Java的HashMap

- 默认初始大小为16
- 默认最大装载因子为0.75
- 当元素个数超过容量的0.75倍时，默认扩容到2倍大
- JDK1.8中为优化HashMap引入`红黑树`，当链表长度超过8时，链表转换为红黑树，当链表长度小于6时，红黑树转换成链表（之所以两个阈值不相同，是为了避免频繁转换）

### 编程语言中哈希算法的运用

#### Java

- HashMap
- LinkedHashMap
- HashSet
- LinkedHashSet
- HashTable
- ConcurrentHashMap

#### Go

- map

#### JavaScript

- Map

#### Python

- [Dict](https://stackoverflow.com/questions/327311/how-are-pythons-built-in-dictionaries-implemented/9022835#9022835)

#### C++

- atd::ordered_map
- unordered_map
- unordered_set

#### php

- [hashTable](https://github.com/Ivanqi/algorithm/blob/master/hash_table/php_hash.md)
- array
  - packed_array(开放寻址法)
  - hash_array(链式寻址)

#### C#

- Dictionary

</details>

### 业界著名哈希算法

- [MD5](https://zh.wikipedia.org/wiki/MD5)
- [SHA](https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F)
- [CRC](https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97)
